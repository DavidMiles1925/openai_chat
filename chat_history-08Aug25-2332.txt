You: Test

--- Model response ---
Jeeves: Hello — Jeeves here. Test received and working. How can I help you today?

You: Just checking an app I developed to chat with you

--- Model response ---
Jeeves: Looks good — Jeeves here. Want me to run through any specific tests or just a quick checklist to exercise common chat-app features?

If helpful, here are things I can do or you can try quickly:
- Basic messaging (short/long).
- Context carryover (send follow-ups that depend on prior messages).
- Streaming/partial responses (if your app supports it).
- Special content: code blocks, markdown, emojis, non-Latin text.
- File/attachment handling (describe a file or paste sample text).
- Error cases: send an invalid request or large payload.
- Rate-limit/retry behavior (rapid-fire requests).
- Latency and reconnect behavior.

Example test prompts you can send me:
- "Summarize the previous 3 messages in one sentence."
- "Write a 200-word explanation of blockchain in simple terms."
- "Generate a short JSON snippet for a to-do app with 3 items."
- "Respond in Spanish: ¿Cómo estás hoy?"
- "Give me a brief unit test for a Python function that reverses a string."

Tell me which you'd like to try or paste a sample conversation and I’ll respond.

You (imported ai_gui.py):
from openai import OpenAI
import threading
import tkinter as tk
from tkinter import scrolledtext, filedialog, Menu
from datetime import datetime
import os
from docx import Document
from pypdf import PdfReader
import base64
import urllib.request
import traceback
import tkinter.font as tkfont

# Pillow for image loading & conversion to Tkinter PhotoImage
from PIL import Image, ImageTk

from config import DEFAULT_MODEL_VERSION, ASSISTANT_NAME, IMAGE_MODEL_VERSION, AVAILABLE_MODELS

try:
    RESAMPLE_FILTER = Image.Resampling.LANCZOS
except AttributeError:
    RESAMPLE_FILTER = getattr(Image, "LANCZOS", Image.BICUBIC)

# Initialize the OpenAI API with your API key
client = OpenAI(
    api_key=os.getenv("OPENAI_KEY", "No_Key"),  # this is also the default, it can be omitted
)

# Default model: prefer the config value if present and in the list, otherwise use the first available
_default_model = DEFAULT_MODEL_VERSION if DEFAULT_MODEL_VERSION in AVAILABLE_MODELS else AVAILABLE_MODELS[0]

# Tk
...[truncated preview]

You: Actually I was hoping to add some functionallity to my program. Right now the API key is stored in the environment variables. I know some similar programs have a way to manage the API key from within the interface. How do they store the API key securely on the system? Do they just add an environment variable under the hood?

--- Model response ---
Jeeves: Nice — good question. Short answer: well-behaved desktop apps typically use the OS-provided secure credential store (Keychain on macOS, Credential Manager / DPAPI on Windows, Secret Service / GNOME Keyring / KWallet on Linux) rather than writing a plain text env var to disk. In Python the easiest cross-platform way to do that is the keyring library, which delegates to the native secure storage on each platform.

Below I outline the options, trade-offs, and a small example you can drop into your Tkinter app.

Options and trade-offs
- OS keychain (recommended)
  - macOS Keychain, Windows Credential Manager/DPAPI, GNOME Keyring/KWallet on Linux.
  - Secure (encrypted by the OS) and user-scoped. Good UX (user can manage credentials in OS UI).
  - Use via Python keyring library (pip install keyring). Keyring chooses the appropriate backend.
- Encrypted file or system APIs
  - You can encrypt a file yourself (e.g., using cryptography and a user password), but that requires secure password handling and is more work.
- Storing in a config file with restricted permissions (0600)
  - Simple but weaker: file could be read by other processes/users if system compromised.
- Environment variables
  - Convenient but ephemeral (session scoped). Some apps set env var at runtime rather than persist it, but they generally don’t write persistent env vars for security reasons.
- Not storing at all
  - Prompt user for API key each run — simplest and most secure against persistent leakage, but worse UX.

Recommendation
- Use keyring to store the API key if the user chooses “Remember API key.” At app startup, check keyring first, then fallback to environment variable (if present), then prompt the user. Do not persist a plaintext key into files or into your repo.

Example integration (Tkinter + keyring)
1) Install:
   pip install keyring

2) Minimal code to store / load / delete key (drop into your app):

from tkinter import simpledialog, messagebox
import keyring
import os

SERVICE_NAME = "gpt_gui_de"   # choose a service name unique to your app
KEYRING_USERNAME = "openai_api_key"  # arbitrary key name/username

def load_api_key():
    # 1) try keyring
    try:
        key = keyring.get_password(SERVICE_NAME, KEYRING_USERNAME)
        if key:
            return key
    except Exception:
        pass
    # 2) try environment variable fallback
    env_key = os.getenv("OPENAI_KEY")
    if env_key and env_key != "No_Key":
        return env_key
    return None

def save_api_key(key):
    try:
        keyring.set_password(SERVICE_NAME, KEYRING_USERNAME, key)
        return True
    except Exception as e:
        print("Failed to save API key to keyring:", e)
        return False

def delete_api_key():
    try:
        keyring.delete_password(SERVICE_NAME, KEYRING_USERNAME)
    except Exception:
        pass

def prompt_for_api_key(parent=None):
    # This uses a simple dialog. Replace with a custom dialog for a nicer UX
    key = simpledialog.askstring("API Key", "Enter your OpenAI API key:", parent=parent)
    if not key:
        return None
    remember = messagebox.askyesno("Remember API key?", "Save this API key to the system keychain so you don't need to enter it again?")
    if remember:
        saved = save_api_key(key)
        if not saved:
            messagebox.showwarning("Warning", "Could not save API key to the system keychain. It will only be used for this session.")
    return key

Usage pattern in your app
- At startup:
    api_key = load_api_key()
    if not api_key:
        api_key = prompt_for_api_key(app)  # pass your Tk root
    if not api_key:
        # user cancelled — decide how to proceed (disable send button, etc.)
    else:
        # Use the key for the OpenAI client (prefer passing it directly rather than setting a persistent env var)
        client = OpenAI(api_key=api_key)

Notes and best practices
- Avoid writing the API key into logs, debug prints, saved chat history, or into a file you commit.
- Prefer passing api_key directly to your client (OpenAI(..., api_key=...)) rather than modifying os.environ persistently. If you do set os.environ, set it only at runtime and do not save it to shell profile files.
- Keyring requires a backend on Linux (GNOME keyring, Secret Service). If no suitable backend exists, keyring may fallback to an insecure backend — detect and warn the user.
- Educate users: let them know where the key is stored and how to remove it (e.g., a Settings -> Forget API Key button that calls delete_api_key()).
- Consider adding a "Test key" button that does a small API call to validate the key before saving.
- Security limits: keyring protects secrets against casual exposure, but it doesn’t protect against malware with access to the user session.

If you want, I can:
- Provide a full Tkinter modal dialog (API key entry + "Remember" checkbox) that integrates into your app,
- Show how to detect insecure keyring backends on Linux and fallback to prompting each run,
- Or modify your existing code to call load_api_key at startup and wire the client creation to it.

Which of those would you like next?

You: Actually what I would like is for you to integrate keyring, but I want to the user to be able to add their API key through a menu at the top. I already have a menu called "File" and a menu called "Model". I would like a new menu called "Key". In the dropdown, I want an option called "Set API Key". The "Set API Key" option should bring up a popup text box where the user can enter their API Key. Is there a way to check if an API Key is set? If there is a way to check that, I would a like a message to pop up in the chat history alerting the user if an API key is NOT set.

--- Model response ---
Jeeves: Perfect — below is a ready-to-drop-in integration that uses the keyring library, adds a "Key" menu with "Set API Key" and "Forget API Key", shows a popup Toplevel where the user can type the API key and choose whether to remember it in the OS keychain, and inserts a chat-history message at startup if no API key is available.

Notes before you paste:
- Install keyring: pip install keyring
- This code keeps the OpenAI client in a global variable and re-initializes it when the user sets a key (so you don't need to set environment variables persistently).
- If the user chooses not to remember the key, it will be used for the current session only.
- If no key is found (keyring or environment), a chat-history message warns the user at startup.

Changes to add to your script
1) Add imports and constants near the top (after your current imports):
    import keyring
    from tkinter import ttk

    SERVICE_NAME = "gpt_gui_de"        # choose an app-specific service name
    KEYRING_USERNAME = "openai_api_key"

2) Add these helper functions (put them near the top where other helpers are defined):

    def load_api_key():
        """
        Try keyring first, then fallback to environment variable.
        Returns None if no usable key found.
        """
        try:
            key = keyring.get_password(SERVICE_NAME, KEYRING_USERNAME)
            if key:
                return key
        except Exception:
            # If keyring backend not available or errors, ignore and fallback to env
            pass

        env_key = os.getenv("OPENAI_KEY")
        if env_key and env_key != "No_Key":
            return env_key
        return None

    def save_api_key_in_keyring(key):
        try:
            keyring.set_password(SERVICE_NAME, KEYRING_USERNAME, key)
            return True
        except Exception as e:
            print("Keyring save error:", e)
            return False

    def delete_api_key_from_keyring():
        try:
            keyring.delete_password(SERVICE_NAME, KEYRING_USERNAME)
        except Exception:
            pass

    def init_client_with_key(key):
        """
        Re-initialize the global OpenAI client based on the provided key.
        If key is None, client will be created without explicit key (so SDK may use env var).
        """
        global client
        try:
            if key:
                client = OpenAI(api_key=key)
            else:
                # fall back to environment variable or uninitialized client
                client = OpenAI()
        except Exception as e:
            # Keep the previous client if initialization fails
            print("Failed to initialize OpenAI client:", e)

3) Add the "Set API Key" UI dialog and menu handlers:

    def set_api_key_dialog(parent=None):
        """
        Show a Toplevel asking for the API key and whether to remember it.
        When the user saves, the client is re-initialized with the provided key.
        """
        dlg = tk.Toplevel(parent or app)
        dlg.title("Set API Key")
        dlg.grab_set()
        dlg.resizable(False, False)

        tk.Label(dlg, text="Enter your OpenAI API key:").grid(row=0, column=0, padx=10, pady=(10,0), sticky='w')
        key_var = tk.StringVar()
        key_entry = tk.Entry(dlg, textvariable=key_var, width=60, show="*")
        key_entry.grid(row=1, column=0, padx=10, pady=6, sticky='we')
        # show/hide button
        show_var = tk.BooleanVar(value=False)
        def toggle_show():
            key_entry.config(show="" if show_var.get() else "*")
        show_cb = tk.Checkbutton(dlg, text="Show key", variable=show_var, command=toggle_show)
        show_cb.grid(row=2, column=0, padx=10, sticky='w')

        remember_var = tk.BooleanVar(value=True)
        remember_cb = tk.Checkbutton(dlg, text="Remember API key in system keychain", variable=remember_var)
        remember_cb.grid(row=3, column=0, padx=10, pady=(4,0), sticky='w')

        button_frame = tk.Frame(dlg)
        button_frame.grid(row=4, column=0, pady=10, padx=10, sticky='e')

        def on_save():
            key = key_var.get().strip()
            if not key:
                # allow clearing (if user wants to forget), but here require non-empty for set
                messagebox.showwarning("No key", "Please enter a non-empty API key or click Cancel.")
                return
            # Save into keyring if requested
            if remember_var.get():
                saved = save_api_key_in_keyring(key)
                if not saved:
                    messagebox.showwarning("Warning", "Could not save API key to system keyring. It will only be used for this session.")
                else:
                    # inform user in chat history
                    chat_history.configure(state='normal')
                    chat_history.insert(tk.END, "API key saved to system keyring.\n\n")
                    chat_history.configure(state='disabled')
                    chat_history.see(tk.END)
            else:
                # user chose not to remember: inform in chat history
                chat_history.configure(state='normal')
                chat_history.insert(tk.END, "API key set for this session only (not saved to keyring).\n\n")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)

            # Initialize client for this session with the provided key
            init_client_with_key(key)

            dlg.destroy()

        def on_cancel():
            dlg.destroy()

        save_btn = tk.Button(button_frame, text="Save", command=on_save)
        save_btn.pack(side='right', padx=6)
        cancel_btn = tk.Button(button_frame, text="Cancel", command=on_cancel)
        cancel_btn.pack(side='right')

        # Pre-fill entry if keyring has a key (useful for editing)
        existing = load_api_key()
        if existing:
            key_var.set(existing)

        key_entry.focus_set()
        dlg.update_idletasks()
        dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

    def forget_api_key():
        delete_api_key_from_keyring()
        # Optionally re-init client without a key (it will use env var or fail)
        init_client_with_key(None)
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "API key removed from system keyring. If you used the key for this session only, it remains active until the app restarts.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

4) Add a new "Key" menu where you build menus (right after Model menu creation block):

    keymenu = Menu(menu, tearoff=0)
    menu.add_cascade(label="Key", menu=keymenu)
    keymenu.add_command(label="Set API Key", command=lambda: set_api_key_dialog(app))
    keymenu.add_command(label="Forget API Key", command=forget_api_key)

5) Replace your existing client initialization at the top with this pattern:
    # Initialize client using any existing key (keyring or env)
    initial_key = load_api_key()
    init_client_with_key(initial_key)

6) Finally, at GUI startup (after you create chat_history widget but before calling mainloop), show a chat-history notice if no key is set:
    def check_api_key_and_warn():
        if load_api_key() is None:
            chat_history.configure(state='normal')
            chat_history.insert(tk.END, "Warning: No API key set. OpenAI requests will fail until you set a key under Key -> Set API Key.\n\n")
            chat_history.configure(state='disabled')
            chat_history.see(tk.END)

    # Call this after chat_history exists (e.g., right before app.mainloop())
    check_api_key_and_warn()

Full integration notes
- The code above references messagebox; you already import tkinter.messagebox earlier as messagebox in your code (you used it in earlier dialog examples). If not, add: from tkinter import messagebox (or use tk.messagebox).
- Because the client is re-initialized whenever the user sets a key, all future chat/image API calls use that key.
- If the user selects Forget API Key, it removes the key from the system keyring but does not forcibly clear any session-only key that the client might already be using until the app restarts (I call init_client_with_key(None) to encourage reinitialization without explicit key).
- On Linux keyring backends: keyring will attempt to use a secure backend (Secret Service/GNOME keyring). If no secure backend exists, keyring might use an insecure file backend. Consider detecting insecure backend and warning users. For most desktop installs where GNOME Keyring or KWallet is present, Keyring will be fine.

Would you like me to:
- Provide a single-paste full version of your script with these changes already applied, or
- Provide a slightly nicer modal that shows success/failure notifications and validates the key with a small test OpenAI call before saving?

You: Provide a slightly nicer modal that shows success/failure notifications and validates the key with a small test OpenAI call before saving

--- Model response ---
Jeeves: Nice — below is a ready-to-drop-in implementation of a nicer modal that validates the API key with a small test OpenAI call before saving it to the OS keychain (via keyring). It:

- Adds a "Key" menu with "Set API Key" and "Forget API Key".
- Shows a Toplevel dialog where user enters key, can show/hide it, and choose "Remember" (save to keyring).
- Validates the key in a background thread (so the UI stays responsive).
- On success, re-initializes the global OpenAI client and shows a success message in chat history.
- On failure, shows an error and lets the user retry.
- Adds a startup warning in chat history if no API key is present.

Prereqs:
- pip install keyring
- Your script already imports: from openai import OpenAI

Copy/paste the code below into your script (place the imports near the top with your other imports). Then:
- Add the "Key" menu lines where you build menus.
- Replace or add the initial client initialization as shown.
- Call check_api_key_and_warn() after chat_history exists and before app.mainloop().

Code to add/replace (drop into your existing file):


# New imports
import keyring
from tkinter import messagebox

# Constants
SERVICE_NAME = "gpt_gui_de"          # change to something unique to your app
KEYRING_USERNAME = "openai_api_key"

# Helper functions for key storage and client init
def load_api_key():
    """
    Try keyring first, then fall back to OPENAI_KEY env var.
    Returns the key string or None.
    """
    try:
        key = keyring.get_password(SERVICE_NAME, KEYRING_USERNAME)
        if key:
            return key
    except Exception:
        # keyring backend may be missing or raise; ignore and fallback
        pass
    env_key = os.getenv("OPENAI_KEY")
    if env_key and env_key != "No_Key":
        return env_key
    return None

def save_api_key_in_keyring(key):
    try:
        keyring.set_password(SERVICE_NAME, KEYRING_USERNAME, key)
        return True
    except Exception as e:
        print("Keyring save error:", e)
        return False

def delete_api_key_from_keyring():
    try:
        keyring.delete_password(SERVICE_NAME, KEYRING_USERNAME)
    except Exception:
        pass

def init_client_with_key(key):
    """
    Re-initialize the global OpenAI client with the given key.
    If key is None, create client without explicit key (SDK will use env var if present).
    """
    global client
    try:
        if key:
            client = OpenAI(api_key=key)
        else:
            client = OpenAI()
    except Exception as e:
        # Keep existing client if initialization fails; log for debugging
        print("Failed to initialize OpenAI client:", e)

# Validation routine: small test call run in background thread
def _validate_key_worker(key, remember_flag, dlg):
    """
    Validate the provided key by performing a tiny API call.
    Runs in a background thread. Uses app.after to update the UI.
    """
    try:
        # Create a temporary client with the candidate key
        temp_client = OpenAI(api_key=key)
        # Try a tiny chat completion (1 token). Use the default model you prefer.
        # We use _default_model (from your config) so validation covers the model you plan to use.
        temp_client.chat.completions.create(
            model=_default_model,
            messages=[{"role": "user", "content": "Say ok in one word"}],
            max_tokens=1
        )
    except Exception as e:
        # Validation failed (network, auth, etc.)
        err_str = str(e)
        def on_fail():
            # Re-enable dialog widgets and show error
            try:
                dlg.status_var.set("Validation failed: " + (err_str[:200] + "..." if len(err_str) > 200 else err_str))
            except Exception:
                pass
            messagebox.showerror("Validation Failed", f"Could not validate the API key:\n\n{err_str}")
            # Re-enable buttons
            try:
                dlg.save_btn.config(state='normal')
                dlg.cancel_btn.config(state='normal')
                dlg.show_cb.config(state='normal')
                dlg.remember_cb.config(state='normal')
                dlg.entry.config(state='normal')
            except Exception:
                pass
        app.after(0, on_fail)
        return

    # If we reach here, validation succeeded
    saved_to_keyring = False
    if remember_flag:
        saved_to_keyring = save_api_key_in_keyring(key)

    # Initialize the real client for the session
    init_client_with_key(key)

    def on_success():
        # Optionally write a success entry into chat_history (no key printed)
        chat_history.configure(state='normal')
        if remember_flag and saved_to_keyring:
            chat_history.insert(tk.END, "API key validated and saved to system keychain.\n\n")
        elif remember_flag and not saved_to_keyring:
            chat_history.insert(tk.END, "API key validated but could not be saved to system keychain (see console). Using it for this session only.\n\n")
        else:
            chat_history.insert(tk.END, "API key validated for this session (not saved to keychain).\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

        messagebox.showinfo("Success", "API key validated successfully.")
        # Close the dialog
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

    app.after(0, on_success)

# The nicer modal dialog that validates before saving
def set_api_key_dialog(parent=None):
    dlg = tk.Toplevel(parent or app)
    dlg.title("Set API Key")
    dlg.grab_set()
    dlg.resizable(False, False)
    dlg.transient(parent or app)

    tk.Label(dlg, text="Enter your OpenAI API key:").grid(row=0, column=0, padx=12, pady=(12, 0), sticky='w')

    key_var = tk.StringVar()
    entry = tk.Entry(dlg, textvariable=key_var, width=60, show="*")
    entry.grid(row=1, column=0, padx=12, pady=6, sticky='we')

    # show/hide checkbox
    show_var = tk.BooleanVar(value=False)
    def toggle_show():
        entry.config(show="" if show_var.get() else "*")
    show_cb = tk.Checkbutton(dlg, text="Show key", variable=show_var, command=toggle_show)
    show_cb.grid(row=2, column=0, padx=12, sticky='w')

    # remember in keychain
    remember_var = tk.BooleanVar(value=True)
    remember_cb = tk.Checkbutton(dlg, text="Remember API key in system keychain", variable=remember_var)
    remember_cb.grid(row=3, column=0, padx=12, pady=(2, 6), sticky='w')

    # status label inside dialog
    status_var = tk.StringVar(value="")
    status_label = tk.Label(dlg, textvariable=status_var, anchor='w', fg='gray30')
    status_label.grid(row=4, column=0, padx=12, pady=(0, 6), sticky='we')

    # button frame
    btn_frame = tk.Frame(dlg)
    btn_frame.grid(row=5, column=0, padx=12, pady=(0, 12), sticky='e')

    def on_save():
        key = key_var.get().strip()
        if not key:
            messagebox.showwarning("No key", "Please enter a non-empty API key or click Cancel.")
            return
        # disable controls while validating
        status_var.set("Validating API key...")
        save_btn.config(state='disabled')
        cancel_btn.config(state='disabled')
        show_cb.config(state='disabled')
        remember_cb.config(state='disabled')
        entry.config(state='disabled')

        # store references on dialog so worker callback can re-enable if needed
        dlg.status_var = status_var
        dlg.save_btn = save_btn
        dlg.cancel_btn = cancel_btn
        dlg.show_cb = show_cb
        dlg.remember_cb = remember_cb
        dlg.entry = entry

        # run validation in background thread
        t = threading.Thread(target=_validate_key_worker, args=(key, remember_var.get(), dlg), daemon=True)
        t.start()

    def on_cancel():
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

    save_btn = tk.Button(btn_frame, text="Validate & Save", command=on_save)
    save_btn.pack(side='right', padx=(6,0))
    cancel_btn = tk.Button(btn_frame, text="Cancel", command=on_cancel)
    cancel_btn.pack(side='right')

    # Pre-fill from any existing key (keyring or env)
    existing = load_api_key()
    if existing:
        key_var.set(existing)

    entry.focus_set()
    dlg.update_idletasks()
    dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

# Forget API key menu action
def forget_api_key():
    delete_api_key_from_keyring()
    # Re-init client with no explicit key so SDK falls back to env var (if any)
    init_client_with_key(None)
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, "API key removed from system keychain. If a key was set for this session it will remain active until you restart the app.\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

# Add the "Key" menu to your menu setup (where menus are created):
# keymenu = Menu(menu, tearoff=0)
# menu.add_cascade(label="Key", menu=keymenu)
# keymenu.add_command(label="Set API Key", command=lambda: set_api_key_dialog(app))
# keymenu.add_command(label="Forget API Key", command=forget_api_key)

# Initialize client at startup using any existing key
initial_key = load_api_key()
init_client_with_key(initial_key)

# Call this after chat_history exists (before app.mainloop()):
def check_api_key_and_warn():
    if load_api_key() is None:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "Warning: No API key set. OpenAI requests will fail until you set a key under Key -> Set API Key.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

How it integrates with your existing code
- Place the new imports near the top of your file.
- Add the helper functions somewhere with your existing helper functions.
- Add the set_api_key_dialog and forget_api_key functions.
- Add the "Key" menu where you already create menu items.
- Replace the original client initialization with the initial_key/init_client_with_key pattern shown.
- Call check_api_key_and_warn() once the chat_history widget is created and before app.mainloop().

Extra suggestions
- Add a small "Test API Key" option in the Key menu if you want manual re-validation later.
- On Linux, keyring may fall back to an insecure backend if no Secret Service/KWallet is available — consider detecting that and warning users if needed.
- Consider disabling the Send / Generate Image buttons until a key is present if you want to force entering a key before allowing calls.

If you want, I can:
- Produce a single full-file version of your script with these modifications already applied, or
- Add a brief UI tweak to visually disable the Send button until a valid key is set. Which would you prefer?

You: Please add a small "Test API Key" option in the Key menu in case I want manual re-validation later. Also, yes please disable the Send / Generate Image buttons until a key is present. Then please provide a full version of the code with all the modifications we have discussed.

--- Model response ---
Jeeves: Below is a complete, ready-to-run version of your script with the requested key management and UI changes:

- Adds a "Key" menu with "Set API Key", "Forget API Key", and "Test API Key".
- Uses the keyring library to store/retrieve keys from the OS keychain (pip install keyring).
- Presents a nicer modal that validates the key with a small test OpenAI call before optionally saving it.
- Disables the Send button and the "Generate Image..." menu item until a valid key is present for the session (or an OPENAI_KEY env var exists).
- Keeps the rest of your original functionality intact (chat, streaming, file import, image generation).
- Provides helpful messages in chat history about the API key state.

Prereqs:
- pip install keyring
- Keep your config.py and other deps as before.

Full script:

```python
from openai import OpenAI
import threading
import tkinter as tk
from tkinter import scrolledtext, filedialog, Menu, messagebox
from datetime import datetime
import os
from docx import Document
from pypdf import PdfReader
import base64
import urllib.request
import traceback
import tkinter.font as tkfont

# Pillow for image loading & conversion to Tkinter PhotoImage
from PIL import Image, ImageTk

# keyring (use OS-provided secure storage). If missing, user must pip install keyring.
try:
    import keyring
except Exception as e:
    keyring = None
    print("Warning: keyring module not available. Install with: pip install keyring")

from config import DEFAULT_MODEL_VERSION, ASSISTANT_NAME, IMAGE_MODEL_VERSION, AVAILABLE_MODELS

try:
    RESAMPLE_FILTER = Image.Resampling.LANCZOS
except AttributeError:
    RESAMPLE_FILTER = getattr(Image, "LANCZOS", Image.BICUBIC)

# -----------------------------
# API key / keyring management
# -----------------------------
SERVICE_NAME = "gpt_gui_de"          # change if you want a different keychain service name
KEYRING_USERNAME = "openai_api_key"

# Track the session key (may be session-only); load_api_key may not see session-only keys,
# so this tracks whether the app currently has a usable key in-memory for the session.
current_session_key = None

def load_api_key():
    """
    Try keyring first, then fall back to the OPENAI_KEY environment variable.
    Returns the key string or None.
    """
    # Try keyring if available
    if keyring:
        try:
            k = keyring.get_password(SERVICE_NAME, KEYRING_USERNAME)
            if k:
                return k
        except Exception:
            # ignore keyring issues and fallback to environment
            pass

    # Fallback to env var
    env_key = os.getenv("OPENAI_KEY")
    if env_key and env_key != "No_Key":
        return env_key
    return None

def save_api_key_in_keyring(key):
    if not keyring:
        print("Keyring not available: cannot save key.")
        return False
    try:
        keyring.set_password(SERVICE_NAME, KEYRING_USERNAME, key)
        return True
    except Exception as e:
        print("Keyring save error:", e)
        return False

def delete_api_key_from_keyring():
    if not keyring:
        return
    try:
        keyring.delete_password(SERVICE_NAME, KEYRING_USERNAME)
    except Exception:
        pass

def init_client_with_key(key):
    """
    Re-initialize the global OpenAI client using key (or none).
    Also updates current_session_key.
    """
    global client, current_session_key
    try:
        if key:
            client = OpenAI(api_key=key)
            current_session_key = key
        else:
            # No explicit key -> let SDK use env var if present
            client = OpenAI()
            # set current_session_key to None (session doesn't have an explicit key)
            current_session_key = None
    except Exception as e:
        print("Failed to initialize OpenAI client:", e)
        # Keep previous client if any; do not alter current_session_key on failure

# -----------------------------
# Validation modal & helpers
# -----------------------------
def _validate_key_worker(key, remember_flag, dlg):
    """
    Validate the provided key by performing a tiny API call.
    Runs in a background thread. Uses app.after to update the UI.
    """
    err = None
    try:
        temp_client = OpenAI(api_key=key)
        # Small test call (very small)
        temp_client.chat.completions.create(
            model=_default_model,
            messages=[{"role": "user", "content": "Say ok in one word"}],
            max_tokens=1
        )
    except Exception as e:
        err = e

    def on_fail():
        try:
            dlg.status_var.set("Validation failed.")
            # Re-enable dialog controls
            dlg.save_btn.config(state='normal')
            dlg.cancel_btn.config(state='normal')
            dlg.show_cb.config(state='normal')
            dlg.remember_cb.config(state='normal')
            dlg.entry.config(state='normal')
        except Exception:
            pass
        err_msg = str(err) if err else "Unknown error"
        messagebox.showerror("Validation Failed", f"Could not validate the API key:\n\n{err_msg}")

    def on_success(saved_to_keyring):
        # Initialize real client
        init_client_with_key(key)
        # Write a success message into chat_history (do not print the key)
        chat_history.configure(state='normal')
        if remember_flag and saved_to_keyring:
            chat_history.insert(tk.END, "API key validated and saved to system keychain.\n\n")
        elif remember_flag and not saved_to_keyring:
            chat_history.insert(tk.END, "API key validated but could not be saved to keychain. Using it for this session only.\n\n")
        else:
            chat_history.insert(tk.END, "API key validated for this session (not saved to keychain).\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

        messagebox.showinfo("Success", "API key validated successfully.")
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

        # Update UI widgets now that we have a valid key
        update_api_widgets()

    if err:
        app.after(0, on_fail)
        return

    # No error: optionally save to keyring
    saved = False
    if remember_flag:
        saved = save_api_key_in_keyring(key)

    app.after(0, lambda: on_success(saved))

def set_api_key_dialog(parent=None):
    dlg = tk.Toplevel(parent or app)
    dlg.title("Set API Key")
    dlg.grab_set()
    dlg.resizable(False, False)
    dlg.transient(parent or app)

    tk.Label(dlg, text="Enter your OpenAI API key:").grid(row=0, column=0, padx=12, pady=(12, 0), sticky='w')

    key_var = tk.StringVar()
    entry = tk.Entry(dlg, textvariable=key_var, width=60, show="*")
    entry.grid(row=1, column=0, padx=12, pady=6, sticky='we')

    # show/hide checkbox
    show_var = tk.BooleanVar(value=False)
    def toggle_show():
        entry.config(show="" if show_var.get() else "*")
    show_cb = tk.Checkbutton(dlg, text="Show key", variable=show_var, command=toggle_show)
    show_cb.grid(row=2, column=0, padx=12, sticky='w')

    # remember in keychain
    remember_var = tk.BooleanVar(value=True)
    remember_cb = tk.Checkbutton(dlg, text="Remember API key in system keychain", variable=remember_var)
    remember_cb.grid(row=3, column=0, padx=12, pady=(2, 6), sticky='w')

    # status label inside dialog
    status_var = tk.StringVar(value="")
    status_label = tk.Label(dlg, textvariable=status_var, anchor='w', fg='gray30')
    status_label.grid(row=4, column=0, padx=12, pady=(0, 6), sticky='we')

    btn_frame = tk.Frame(dlg)
    btn_frame.grid(row=5, column=0, padx=12, pady=(0, 12), sticky='e')

    def on_save():
        key = key_var.get().strip()
        if not key:
            messagebox.showwarning("No key", "Please enter a non-empty API key or click Cancel.")
            return
        # disable controls while validating
        status_var.set("Validating API key...")
        save_btn.config(state='disabled')
        cancel_btn.config(state='disabled')
        show_cb.config(state='disabled')
        remember_cb.config(state='disabled')
        entry.config(state='disabled')

        # Attach some references so worker can re-enable if needed
        dlg.status_var = status_var
        dlg.save_btn = save_btn
        dlg.cancel_btn = cancel_btn
        dlg.show_cb = show_cb
        dlg.remember_cb = remember_cb
        dlg.entry = entry

        t = threading.Thread(target=_validate_key_worker, args=(key, remember_var.get(), dlg), daemon=True)
        t.start()

    def on_cancel():
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

    save_btn = tk.Button(btn_frame, text="Validate & Save", command=on_save)
    save_btn.pack(side='right', padx=(6,0))
    cancel_btn = tk.Button(btn_frame, text="Cancel", command=on_cancel)
    cancel_btn.pack(side='right')

    # Pre-fill from any existing key (keyring or env)
    existing = load_api_key()
    if existing:
        key_var.set(existing)

    entry.focus_set()
    dlg.update_idletasks()
    dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

def forget_api_key():
    delete_api_key_from_keyring()
    # Do not forcibly clear session key (session-only key remains until restarted),
    # but re-init client without explicit key so SDK falls back to env var (if any).
    init_client_with_key(None)
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, "API key removed from system keychain. If you set a key for this session it will remain active until the app restarts.\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)
    update_api_widgets()

def test_api_key():
    """
    Manual re-validation of the currently stored key (keyring or env or session).
    Runs in background and reports success/failure.
    """
    # Prefer session key, then keyring/env
    candidate = current_session_key or load_api_key()
    if not candidate:
        messagebox.showinfo("No API Key", "No API key is set. Use Key -> Set API Key first.")
        return

    def worker():
        try:
            temp_client = OpenAI(api_key=candidate)
            temp_client.chat.completions.create(
                model=_default_model,
                messages=[{"role": "user", "content": "Say ok in one word"}],
                max_tokens=1
            )
        except Exception as e:
            app.after(0, lambda: messagebox.showerror("Test Failed", f"API key test failed:\n\n{e}"))
            return
        app.after(0, lambda: messagebox.showinfo("Test Succeeded", "API key is valid."))

    threading.Thread(target=worker, daemon=True).start()

# -----------------------------
# Initialize the OpenAI client variable (we'll initialize properly later)
# -----------------------------
client = None

# Default model: prefer the config value if present and in the list, otherwise use first available
_default_model = DEFAULT_MODEL_VERSION if DEFAULT_MODEL_VERSION in AVAILABLE_MODELS else AVAILABLE_MODELS[0]

# -----------------------------
# Tkinter app state & helpers
# -----------------------------
conversation = [
    {"role": "system", "content": f"You are chatting with a user. Respond helpfully. Your name is {ASSISTANT_NAME}"}
]

conversation_lock = threading.Lock()

waiting = False
anim_after_id = None
anim_dots = 0

image_refs = []
default_image_folder = os.getcwd()

def animate_wait():
    global anim_dots, anim_after_id
    if not waiting:
        return
    anim_dots = (anim_dots + 1) % 4
    status_label.config(text="Thinking" + "." * anim_dots)
    anim_after_id = app.after(500, animate_wait)

def start_waiting():
    global waiting, anim_dots, anim_after_id
    if waiting:
        return
    waiting = True
    anim_dots = 0
    status_label.config(text="Thinking")
    anim_after_id = app.after(500, animate_wait)

def stop_waiting():
    global waiting, anim_after_id
    if not waiting:
        return
    waiting = False
    if anim_after_id is not None:
        try:
            app.after_cancel(anim_after_id)
        except Exception:
            pass
        anim_after_id = None
    status_label.config(text="Idle")

# -----------------------------
# Chat send (streaming) & image generation
# -----------------------------
def send_message():
    user_message = user_input.get("1.0", tk.END).strip()
    if not user_message:
        return

    # Disable the send button on the main thread immediately
    send_button.config(state='disabled')

    with conversation_lock:
        conversation.append({"role": "user", "content": user_message})

    def show_user_message():
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "You: " + user_message + "\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
        user_input.delete("1.0", tk.END)

    app.after(0, show_user_message)
    start_waiting()

    selected_model = current_model_var.get()

    def worker(model_to_use):
        try:
            with conversation_lock:
                messages_for_api = conversation.copy()

            stream = client.chat.completions.create(
                model=model_to_use,
                messages=messages_for_api,
                stream=True
            )

            def start_assistant_message():
                chat_history.configure(state='normal')
                sep = "\n--- Model response ---\n"
                chat_history.insert(tk.END, sep, "separator")
                chat_history.insert(tk.END, f"{ASSISTANT_NAME}: ")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)

            app.after(0, start_assistant_message)

            assistant_full = ""

            for event in stream:
                delta_text = ""
                try:
                    choice0 = event.choices[0]
                    delta = getattr(choice0, "delta", None)
                    if delta is None:
                        delta = choice0.get("delta", {})
                    if hasattr(delta, "content"):
                        delta_text = delta.content or ""
                    else:
                        delta_text = delta.get("content", "") if isinstance(delta, dict) else ""
                except Exception:
                    delta_text = ""

                if delta_text:
                    assistant_full += delta_text
                    def append_chunk(chunk=delta_text):
                        chat_history.configure(state='normal')
                        chat_history.insert(tk.END, chunk)
                        chat_history.configure(state='disabled')
                        chat_history.see(tk.END)
                    app.after(0, append_chunk)

            def finalize_assistant_message():
                chat_history.configure(state='normal')
                chat_history.insert(tk.END, "\n\n")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)

            app.after(0, finalize_assistant_message)

            with conversation_lock:
                conversation.append({"role": "assistant", "content": assistant_full})

        except Exception as e:
            def show_error():
                chat_history.configure(state='normal')
                chat_history.insert(tk.END, "Error: " + str(e) + "\n\n")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)
            app.after(0, show_error)

        finally:
            def on_request_complete():
                send_button.config(state='normal')
                stop_waiting()
            app.after(0, on_request_complete)

    t = threading.Thread(target=worker, args=(selected_model,), daemon=True)
    t.start()

def export_chat():
    filename = f'chat_history-{datetime.now().strftime("%m%b%y-%H%M")}.txt'
    chat_content = chat_history.get('1.0', tk.END)
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(chat_content)
    print(f"Exported {filename}")

def read_text_file(path):
    with open(path, 'r', encoding='utf-8', errors='replace') as f:
        return f.read()

def read_docx_file(path):
    try:
        doc = Document(path)
    except Exception as e:
        raise RuntimeError(f"Error reading DOCX: {e}")
    paragraphs = [p.text for p in doc.paragraphs]
    return "\n".join(paragraphs)

def read_pdf_file(path):
    try:
        reader = PdfReader(path)
    except Exception as e:
        raise RuntimeError(f"Error opening PDF: {e}")
    text_chunks = []
    for page in reader.pages:
        try:
            text = page.extract_text()
        except Exception:
            text = None
        if text:
            text_chunks.append(text)
    return "\n\n".join(text_chunks)

def read_excel_file(path):
    try:
        import pandas as pd
        sheets = pd.read_excel(path, sheet_name=None)
        parts = []
        for sheet_name, df in sheets.items():
            parts.append(f"Sheet: {sheet_name}")
            parts.append(df.to_csv(sep='\t', index=False))
        return "\n\n".join(parts)
    except Exception as pandas_err:
        try:
            from openpyxl import load_workbook
            wb = load_workbook(path, read_only=True, data_only=True)
            parts = []
            for sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                parts.append(f"Sheet: {sheet_name}")
                rows = []
                for row in ws.iter_rows(values_only=True):
                    row_text = "\t".join("" if v is None else str(v) for v in row)
                    rows.append(row_text)
                parts.append("\n".join(rows))
            return "\n\n".join(parts)
        except Exception as openpyxl_err:
            raise RuntimeError(
                "Failed to read Excel file. pandas error: "
                f"{pandas_err}; openpyxl error: {openpyxl_err}. "
                "To add Excel support install pandas and openpyxl (e.g. pip install pandas openpyxl)."
            )

def import_file():
    filepath = filedialog.askopenfilename(
        title="Import file for context",
        filetypes=[
            ("All files", "*.*"),
            ("Text files", "*.txt;*.md"),
            ("Word documents", "*.docx"),
            ("PDF files", "*.pdf"),
            ("Excel files", "*.xls;*.xlsx")
        ]
    )
    if not filepath:
        return

    ext = os.path.splitext(filepath)[1].lower()
    try:
        if ext in ('.txt', '.md'):
            content = read_text_file(filepath)
        elif ext == '.docx':
            content = read_docx_file(filepath)
        elif ext == '.pdf':
            content = read_pdf_file(filepath)
        elif ext in ('.xls', '.xlsx'):
            content = read_excel_file(filepath)
        else:
            try:
                content = read_text_file(filepath)
            except Exception:
                raise RuntimeError("Unsupported file type and not readable as text.")
    except Exception as e:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, f"Error importing file {os.path.basename(filepath)}: {e}\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
        return

    max_chars_warn = 200_000
    if len(content) > max_chars_warn:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END,
                            f"Warning: imported file is very large ({len(content)} chars). "
                            "You may want to summarize or split it before sending to the model.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

    with conversation_lock:
        conversation.append({"role": "user", "content": content})

    preview_limit = 1000
    preview = content if len(content) <= preview_limit else content[:preview_limit] + "\n...[truncated preview]"
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"You (imported {os.path.basename(filepath)}):\n{preview}\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

# ------------------------------
# Image generation functions
# ------------------------------
def generate_image_dialog():
    dlg = tk.Toplevel(app)
    dlg.title("Generate Image")
    dlg.grab_set()

    tk.Label(dlg, text="Enter image prompt:").grid(row=0, column=0, padx=8, pady=(8, 0), sticky='w')
    prompt_text = tk.Text(dlg, wrap=tk.WORD, width=60, height=6)
    prompt_text.grid(row=1, column=0, padx=8, pady=8, sticky='nsew')

    size_frame = tk.Frame(dlg)
    size_frame.grid(row=2, column=0, sticky='w', padx=8)
    tk.Label(size_frame, text="Size:").pack(side='left', padx=(0,6))
    size_var = tk.StringVar(value="1024x1024")
    size_choices = ["256x256", "512x512", "1024x1024"]
    size_menu = tk.OptionMenu(size_frame, size_var, *size_choices)
    size_menu.pack(side='left')

    folder_frame = tk.Frame(dlg)
    folder_frame.grid(row=3, column=0, sticky='we', padx=8, pady=(6, 0))
    tk.Label(folder_frame, text="Save folder:").pack(side='left')
    folder_label_var = tk.StringVar(value=default_image_folder)
    folder_label = tk.Label(folder_frame, textvariable=folder_label_var, anchor='w')
    folder_label.pack(side='left', padx=(6,8), fill='x', expand=True)

    def choose_folder():
        chosen = filedialog.askdirectory(title="Choose folder to save images", initialdir=folder_label_var.get() or os.getcwd())
        if chosen:
            folder_label_var.set(chosen)

    choose_btn = tk.Button(folder_frame, text="Choose...", command=choose_folder)
    choose_btn.pack(side='right')

    button_frame = tk.Frame(dlg)
    button_frame.grid(row=4, column=0, pady=(8, 8), sticky='e')

    def on_submit():
        prompt = prompt_text.get("1.0", tk.END).strip()
        if not prompt:
            return
        size = size_var.get()
        folder = folder_label_var.get() or os.getcwd()
        dlg.destroy()
        start_image_generation(prompt, size, folder)

    submit_btn = tk.Button(button_frame, text="Generate", command=on_submit)
    submit_btn.pack(side='right', padx=5)
    cancel_btn = tk.Button(button_frame, text="Cancel", command=dlg.destroy)
    cancel_btn.pack(side='right')

    dlg.update_idletasks()
    dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

def start_image_generation(prompt, size, folder):
    with conversation_lock:
        conversation.append({"role": "user", "content": f"[Image prompt] {prompt}"})

    app.after(0, lambda: show_user_prompt_ui(prompt, size))
    start_waiting()
    send_button.config(state='disabled')

    t = threading.Thread(target=image_worker, args=(prompt, size, folder), daemon=True)
    t.start()

def image_worker(prompt, size, folder):
    try:
        os.makedirs(folder, exist_ok=True)

        response = client.images.generate(
            model=IMAGE_MODEL_VERSION,
            prompt=prompt,
            size=size
        )

        img_b64 = None
        img_url = None
        try:
            first = response.data[0]
            img_b64 = getattr(first, "b64_json", None) or (first.get("b64_json") if isinstance(first, dict) else None)
            img_url = getattr(first, "url", None) or (first.get("url") if isinstance(first, dict) else None)
        except Exception:
            pass

        saved_filename = None
        if img_b64:
            try:
                img_bytes = base64.b64decode(img_b64)
                saved_filename = os.path.join(folder, f"image-{datetime.now().strftime('%Y%m%d-%H%M%S')}.png")
                with open(saved_filename, "wb") as f:
                    f.write(img_bytes)
            except Exception as e:
                raise RuntimeError(f"Failed to decode/save image: {e}")
        elif img_url:
            try:
                saved_filename = os.path.join(folder, f"image-{datetime.now().strftime('%Y%m%d-%H%M%S')}.png")
                urllib.request.urlretrieve(img_url, saved_filename)
            except Exception as e:
                raise RuntimeError(f"Failed to download image from URL: {e}")
        else:
            raise RuntimeError(f"No image data returned. Response: {response}")

        assistant_text = f"[Image generated: {saved_filename}] (prompt: {prompt})"
        with conversation_lock:
            conversation.append({"role": "assistant", "content": assistant_text})

        app.after(0, lambda: show_assistant_image_ui(saved_filename, assistant_text))

    except Exception as e:
        print("Image generation error:", traceback.format_exc())
        app.after(0, lambda: show_image_error_ui(e))

    finally:
        app.after(0, cleanup_after_image)

def show_user_prompt_ui(prompt, size):
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"You (image prompt, {size}): {prompt}\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

def show_assistant_image_ui(saved_filename, assistant_text):
    try:
        chat_history.configure(state='normal')
        sep = "\n--- Model response ---\n"
        chat_history.insert(tk.END, sep, "separator")
        chat_history.insert(tk.END, f"{ASSISTANT_NAME}: {assistant_text}\n")

        pil_img = Image.open(saved_filename)

        chat_width = chat_history.winfo_width()
        if not chat_width or chat_width < 50:
            max_display_width = 600
        else:
            max_display_width = max(200, chat_width - 80)

        w, h = pil_img.size
        if w > max_display_width:
            ratio = max_display_width / w
            new_size = (int(w * ratio), int(h * ratio))
            pil_img = pil_img.resize(new_size, resample=RESAMPLE_FILTER)

        tk_img = ImageTk.PhotoImage(pil_img)
        image_refs.append(tk_img)

        chat_history.image_create(tk.END, image=tk_img)
        chat_history.insert(tk.END, "\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

    except Exception as e_ui:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, f"Error displaying image: {e_ui}\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

def show_image_error_ui(exc):
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, "Error generating image: " + str(exc) + "\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

def cleanup_after_image():
    send_button.config(state='normal')
    stop_waiting()

# ------------------------------
# Model menu change handler
# ------------------------------
def on_model_change():
    selected = current_model_var.get()
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"[Model switched to: {selected}]\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

# ------------------------------
# Build the GUI
# ------------------------------
app = tk.Tk()
app.title("GPT GUIde")

# Default UI model selection variable
current_model_var = tk.StringVar(app, value=_default_model)

menu = Menu(app)
app.config(menu=menu)

# File menu
filemenu = Menu(menu, tearoff=0)
menu.add_cascade(label="File", menu=filemenu)
filemenu.add_command(label="Export Chat", command=export_chat)
filemenu.add_command(label="Import File", command=import_file)
filemenu.add_command(label="Generate Image...", command=generate_image_dialog)
# capture index of generate image command so we can enable/disable it later
_generate_image_menu_index = filemenu.index("end")

# Model menu
modelmenu = Menu(menu, tearoff=0)
menu.add_cascade(label="Model", menu=modelmenu)
for m in AVAILABLE_MODELS:
    modelmenu.add_radiobutton(label=m, variable=current_model_var, value=m, command=on_model_change)

# Key menu (Set / Forget / Test)
keymenu = Menu(menu, tearoff=0)
menu.add_cascade(label="Key", menu=keymenu)
keymenu.add_command(label="Set API Key", command=lambda: set_api_key_dialog(app))
keymenu.add_command(label="Forget API Key", command=forget_api_key)
keymenu.add_command(label="Test API Key", command=test_api_key)

# Configure grid weights
app.grid_rowconfigure(0, weight=1)
app.grid_rowconfigure(1, weight=0)
app.grid_rowconfigure(2, weight=0)
app.grid_rowconfigure(3, weight=0)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=0, minsize=80)

chat_history = scrolledtext.ScrolledText(app, state='disabled', wrap=tk.WORD)
chat_history.grid(row=0, column=0, columnspan=2, padx=10, pady=10, sticky='nsew')

default_font = tkfont.nametofont("TkDefaultFont")
sep_font = default_font.copy()
try:
    sep_font.configure(size=max(default_font.cget("size") - 2, 8), slant='italic')
except Exception:
    sep_font = ("TkDefaultFont", max(default_font.cget("size") - 2, 8), "italic")
chat_history.tag_configure("separator", font=sep_font, foreground="gray")

user_input = tk.Text(app, wrap=tk.WORD, height=4)
user_input.grid(row=1, column=0, padx=10, pady=10, sticky='nsew')

send_button = tk.Button(app, text="Send", command=send_message)
send_button.grid(row=1, column=1, padx=10, pady=10, sticky='ns')

status_label = tk.Label(app, text="Idle", anchor='w')
status_label.grid(row=2, column=0, columnspan=2, sticky='ew', padx=10, pady=(0,2))

credit_font = default_font.copy()
try:
    credit_font.configure(size=max(default_font.cget("size") - 3, 8), slant='italic')
except Exception:
    credit_font = ("TkDefaultFont", max(default_font.cget("size") - 3, 8), "italic")
credit_label = tk.Label(app, text="Created by David Miles", anchor='e', font=credit_font, foreground="gray30")
credit_label.grid(row=3, column=0, columnspan=2, sticky='ew', padx=10, pady=(0,10))

app.update_idletasks()
min_w = app.winfo_reqwidth()
min_h = app.winfo_reqheight()
app.minsize(min_w, min_h)
app.geometry(f"{min_w}x{min_h}")

# ------------------------------
# API key initialization + widget enabling
# ------------------------------
# Initialize client using any existing key (keyring or env)
initial_key = load_api_key()
init_client_with_key(initial_key)

def update_api_widgets():
    """
    Enable or disable UI elements that require an API key.
    Criteria: session key present (current_session_key) OR environment variable present.
    """
    has_env_key = bool(os.getenv("OPENAI_KEY"))
    has_key_for_session = bool(current_session_key) or has_env_key

    # Send button
    try:
        send_button.config(state='normal' if has_key_for_session else 'disabled')
    except Exception:
        pass

    # Generate Image menu entry (in File menu), using the captured index
    try:
        filemenu.entryconfig(_generate_image_menu_index, state='normal' if has_key_for_session else 'disabled')
    except Exception:
        pass

# Warn in chat if no key present and update widgets accordingly
def check_api_key_and_warn():
    if load_api_key() is None and not current_session_key and not os.getenv("OPENAI_KEY"):
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "Warning: No API key set. OpenAI requests will fail until you set a key under Key -> Set API Key.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
    update_api_widgets()

# Call initial check now that widgets exist
check_api_key_and_warn()

# Start main loop
app.mainloop()
```

Notes and suggestions
- The dialog validates by making a tiny chat call to the selected default model; this uses one token and should be cheap. If you want a different validation call (images/embeddings), we can change it.
- On Linux, keyring will attempt to use a Secret Service backend. If none is available it may fall back to an insecure backend; you can detect keyring.get_keyring().__class__ and warn users. If you’d like I can add that detection and a warning dialog.
- I kept the behavior that "Forget API Key" removes the stored key but does not forcibly clear any session-only key (so the session continues until restart). If you want Forget to fully clear the session (force re-init without a key and disable buttons), call init_client_with_key(None) and clear current_session_key; I left it as a soft removal and re-init to let env var remain if present.
- The UI elements that required keys were the Send button and the "Generate Image..." menu entry. If you add any other API-dependent controls, call update_api_widgets() to update them.

If you want, I can:
- Add a small indicator in the status bar showing "API key: saved / session-only / none".
- Make the "Test API Key" menu item show a progress dialog while validating.
- Add detection for insecure keyring backends on Linux and show a warning during Set API Key.

Would you like any of those refinements?

You (imported requirements.txt):
# Core runtime
openai>=1.0.0,<3.0.0
python-docx>=0.8.11,<1.0.0
pypdf>=3.7.0,<5.0.0
Pillow>=9.0.0,<11.0.0
pandas>=1.5.3,<2.0.0
openpyxl>=3.0.10,<4.0.0
xlrd>=1.2.0,<2.0.0

You: Can you please update my requirements file and post the full updated file?

--- Model response ---
Jeeves: Here's the updated requirements file including keyring for OS keychain support. I added an optional secretstorage line (commented) which can improve Linux Secret Service support but may require system-level dependencies.

Contents for requirements.txt:

# Core runtime
openai>=1.0.0,<3.0.0
python-docx>=0.8.11,<1.0.0
pypdf>=3.7.0,<5.0.0
Pillow>=9.0.0,<11.0.0
pandas>=1.5.3,<2.0.0
openpyxl>=3.0.10,<4.0.0
xlrd>=1.2.0,<2.0.0
keyring>=23.0.0,<24.0.0

# Optional: improves keyring Secret Service backend on Linux (may require system packages such as dbus)
# secretstorage>=3.3.0,<4.0.0

If you want, I can also:
- Pick a different keyring version constraint,
- Add cryptography/secretstorage un-commented if you prefer to install Linux Secret Service support by default.

You: When I click the "Test API Key" I get and error: Exception in Tkinter callback
Traceback (most recent call last):
  File "C:\Users\astro\AppData\Local\Programs\Python\Python312\Lib\tkinter\__init__.py", line 1948, in __call__
    return self.func(*args)
           ^^^^^^^^^^^^^^^^
  File "C:\Users\astro\AppData\Local\Programs\Python\Python312\Lib\tkinter\__init__.py", line 861, in callit
    func(*args)
  File "c:\Users\astro\OneDrive\David's IT Garage\AI Development\python_streaming\ai_gui.py", line 278, in <lambda>
    app.after(0, lambda: messagebox.showerror("Test Failed", f"API key test failed:\n\n{e}"))
                                                                                        ^
NameError: cannot access free variable 'e' where it is not associated with a value in enclosing scope

--- Model response ---
Jeeves: Thanks — that error happens because the exception variable (e) from the except block is deleted when the except block finishes, so the lambda scheduled to run later can't access it. The fix is to capture the error text into a local string inside the except block and pass that into the lambda (or bind it as a default argument on the lambda).

Replace your test_api_key function with the following corrected version:

def test_api_key():
    """
    Manual re-validation of the currently stored key (keyring or env or session).
    Runs in background and reports success/failure.
    """
    candidate = current_session_key or load_api_key()
    if not candidate:
        messagebox.showinfo("No API Key", "No API key is set. Use Key -> Set API Key first.")
        return

    def worker():
        try:
            temp_client = OpenAI(api_key=candidate)
            temp_client.chat.completions.create(
                model=_default_model,
                messages=[{"role": "user", "content": "Say ok in one word"}],
                max_tokens=1
            )
        except Exception as exc:
            # capture error string now (exception vars are cleared after the except block)
            err_msg = str(exc)
            app.after(0, lambda msg=err_msg: messagebox.showerror("Test Failed", f"API key test failed:\n\n{msg}"))
            return
        app.after(0, lambda: messagebox.showinfo("Test Succeeded", "API key is valid."))

    threading.Thread(target=worker, daemon=True).start()

Notes
- The key change is capturing str(exc) in err_msg and binding it to the lambda with msg=err_msg so the message is safe to use when the lambda runs on the main thread.
- You should scan for other places where you schedule a callback from an except block that references the exception object inside a lambda or nested function scheduled to run later — apply the same pattern there (capture str(e) or bind it as a default arg).
- After updating, restart the app and click Key -> Test API Key to confirm it shows success/failure dialogs correctly.

If you want, I can produce a small patch or the full updated file with this change applied. Which would you prefer?

You: Now I get an error code 400. It says Upsupported Parameter: max_tokens is not supported with this model. Use max_completion_tokens instead

--- Model response ---
Jeeves: That error means the model / SDK you’re calling expects the newer parameter name max_completion_tokens instead of max_tokens. Change any small validation/test calls that use max_tokens to use max_completion_tokens.

In your code you have two places to update: the validation worker (_validate_key_worker) and the test_api_key worker. Replace max_tokens=1 with max_completion_tokens=1. Example corrected snippets:

1) _validate_key_worker (replace the test call)
Before:
temp_client.chat.completions.create(
    model=_default_model,
    messages=[{"role": "user", "content": "Say ok in one word"}],
    max_tokens=1
)

After:
temp_client.chat.completions.create(
    model=_default_model,
    messages=[{"role": "user", "content": "Say ok in one word"}],
    max_completion_tokens=1
)

2) test_api_key worker
Before:
temp_client.chat.completions.create(
    model=_default_model,
    messages=[{"role": "user", "content": "Say ok in one word"}],
    max_tokens=1
)

After:
temp_client.chat.completions.create(
    model=_default_model,
    messages=[{"role": "user", "content": "Say ok in one word"}],
    max_completion_tokens=1
)

Quick search tip: search your codebase for "max_tokens=" and replace occurrences with "max_completion_tokens=" when calling chat.completions.create on this SDK/version.

Notes and small precautions
- Different APIs / SDK versions sometimes use different parameter names (old OpenAI libs used max_tokens). If you call other endpoints (e.g., responses, completions), check that endpoint’s docs for the correct parameter name.
- Keep validation calls small (one token) to minimize cost.
- If you’d like, I can patch your full script and return the corrected file with these replacements applied. Would you like that?

You: Please patch the full script and return the corrected file

--- Model response ---
Jeeves: Here's the full patched script with the fixes applied:

- Replaced max_tokens with max_completion_tokens in the validation/test calls.
- Fixed the exception capture in the Test API Key worker so the error message is preserved for the main-thread callback (no NameError).
- Kept the rest of the previously provided functionality (keyring integration, nicer modal, disabling send/generate image until key present, etc.).

```python
from openai import OpenAI
import threading
import tkinter as tk
from tkinter import scrolledtext, filedialog, Menu, messagebox
from datetime import datetime
import os
from docx import Document
from pypdf import PdfReader
import base64
import urllib.request
import traceback
import tkinter.font as tkfont

# Pillow for image loading & conversion to Tkinter PhotoImage
from PIL import Image, ImageTk

# keyring (use OS-provided secure storage). If missing, user must pip install keyring.
try:
    import keyring
except Exception as e:
    keyring = None
    print("Warning: keyring module not available. Install with: pip install keyring")

from config import DEFAULT_MODEL_VERSION, ASSISTANT_NAME, IMAGE_MODEL_VERSION, AVAILABLE_MODELS

try:
    RESAMPLE_FILTER = Image.Resampling.LANCZOS
except AttributeError:
    RESAMPLE_FILTER = getattr(Image, "LANCZOS", Image.BICUBIC)

# -----------------------------
# API key / keyring management
# -----------------------------
SERVICE_NAME = "gpt_gui_de"          # change if you want a different keychain service name
KEYRING_USERNAME = "openai_api_key"

# Track the session key (may be session-only); load_api_key may not see session-only keys,
# so this tracks whether the app currently has a usable key in-memory for the session.
current_session_key = None

def load_api_key():
    """
    Try keyring first, then fall back to the OPENAI_KEY environment variable.
    Returns the key string or None.
    """
    # Try keyring if available
    if keyring:
        try:
            k = keyring.get_password(SERVICE_NAME, KEYRING_USERNAME)
            if k:
                return k
        except Exception:
            # ignore keyring issues and fallback to environment
            pass

    # Fallback to env var
    env_key = os.getenv("OPENAI_KEY")
    if env_key and env_key != "No_Key":
        return env_key
    return None

def save_api_key_in_keyring(key):
    if not keyring:
        print("Keyring not available: cannot save key.")
        return False
    try:
        keyring.set_password(SERVICE_NAME, KEYRING_USERNAME, key)
        return True
    except Exception as e:
        print("Keyring save error:", e)
        return False

def delete_api_key_from_keyring():
    if not keyring:
        return
    try:
        keyring.delete_password(SERVICE_NAME, KEYRING_USERNAME)
    except Exception:
        pass

def init_client_with_key(key):
    """
    Re-initialize the global OpenAI client using key (or none).
    Also updates current_session_key.
    """
    global client, current_session_key
    try:
        if key:
            client = OpenAI(api_key=key)
            current_session_key = key
        else:
            # No explicit key -> let SDK use env var if present
            client = OpenAI()
            # set current_session_key to None (session doesn't have an explicit key)
            current_session_key = None
    except Exception as e:
        print("Failed to initialize OpenAI client:", e)
        # Keep previous client if any; do not alter current_session_key on failure

# -----------------------------
# Validation modal & helpers
# -----------------------------
def _validate_key_worker(key, remember_flag, dlg):
    """
    Validate the provided key by performing a tiny API call.
    Runs in a background thread. Uses app.after to update the UI.
    """
    err = None
    err_msg = None
    try:
        temp_client = OpenAI(api_key=key)
        # Small test call (very small) — use new param name max_completion_tokens
        temp_client.chat.completions.create(
            model=_default_model,
            messages=[{"role": "user", "content": "Say ok in one word"}],
            max_completion_tokens=1
        )
    except Exception as e:
        err = e
        err_msg = str(e)

    def on_fail():
        try:
            dlg.status_var.set("Validation failed.")
            # Re-enable dialog controls
            dlg.save_btn.config(state='normal')
            dlg.cancel_btn.config(state='normal')
            dlg.show_cb.config(state='normal')
            dlg.remember_cb.config(state='normal')
            dlg.entry.config(state='normal')
        except Exception:
            pass
        messagebox.showerror("Validation Failed", f"Could not validate the API key:\n\n{err_msg}")

    def on_success(saved_to_keyring):
        # Initialize real client
        init_client_with_key(key)
        # Write a success message into chat_history (do not print the key)
        chat_history.configure(state='normal')
        if remember_flag and saved_to_keyring:
            chat_history.insert(tk.END, "API key validated and saved to system keychain.\n\n")
        elif remember_flag and not saved_to_keyring:
            chat_history.insert(tk.END, "API key validated but could not be saved to keychain. Using it for this session only.\n\n")
        else:
            chat_history.insert(tk.END, "API key validated for this session (not saved to keychain).\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

        messagebox.showinfo("Success", "API key validated successfully.")
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

        # Update UI widgets now that we have a valid key
        update_api_widgets()

    if err:
        app.after(0, on_fail)
        return

    # No error: optionally save to keyring
    saved = False
    if remember_flag:
        saved = save_api_key_in_keyring(key)

    app.after(0, lambda: on_success(saved))

def set_api_key_dialog(parent=None):
    dlg = tk.Toplevel(parent or app)
    dlg.title("Set API Key")
    dlg.grab_set()
    dlg.resizable(False, False)
    dlg.transient(parent or app)

    tk.Label(dlg, text="Enter your OpenAI API key:").grid(row=0, column=0, padx=12, pady=(12, 0), sticky='w')

    key_var = tk.StringVar()
    entry = tk.Entry(dlg, textvariable=key_var, width=60, show="*")
    entry.grid(row=1, column=0, padx=12, pady=6, sticky='we')

    # show/hide checkbox
    show_var = tk.BooleanVar(value=False)
    def toggle_show():
        entry.config(show="" if show_var.get() else "*")
    show_cb = tk.Checkbutton(dlg, text="Show key", variable=show_var, command=toggle_show)
    show_cb.grid(row=2, column=0, padx=12, sticky='w')

    # remember in keychain
    remember_var = tk.BooleanVar(value=True)
    remember_cb = tk.Checkbutton(dlg, text="Remember API key in system keychain", variable=remember_var)
    remember_cb.grid(row=3, column=0, padx=12, pady=(2, 6), sticky='w')

    # status label inside dialog
    status_var = tk.StringVar(value="")
    status_label = tk.Label(dlg, textvariable=status_var, anchor='w', fg='gray30')
    status_label.grid(row=4, column=0, padx=12, pady=(0, 6), sticky='we')

    btn_frame = tk.Frame(dlg)
    btn_frame.grid(row=5, column=0, padx=12, pady=(0, 12), sticky='e')

    def on_save():
        key = key_var.get().strip()
        if not key:
            messagebox.showwarning("No key", "Please enter a non-empty API key or click Cancel.")
            return
        # disable controls while validating
        status_var.set("Validating API key...")
        save_btn.config(state='disabled')
        cancel_btn.config(state='disabled')
        show_cb.config(state='disabled')
        remember_cb.config(state='disabled')
        entry.config(state='disabled')

        # Attach some references so worker can re-enable if needed
        dlg.status_var = status_var
        dlg.save_btn = save_btn
        dlg.cancel_btn = cancel_btn
        dlg.show_cb = show_cb
        dlg.remember_cb = remember_cb
        dlg.entry = entry

        t = threading.Thread(target=_validate_key_worker, args=(key, remember_var.get(), dlg), daemon=True)
        t.start()

    def on_cancel():
        try:
            dlg.grab_release()
            dlg.destroy()
        except Exception:
            pass

    save_btn = tk.Button(btn_frame, text="Validate & Save", command=on_save)
    save_btn.pack(side='right', padx=(6,0))
    cancel_btn = tk.Button(btn_frame, text="Cancel", command=on_cancel)
    cancel_btn.pack(side='right')

    # Pre-fill from any existing key (keyring or env)
    existing = load_api_key()
    if existing:
        key_var.set(existing)

    entry.focus_set()
    dlg.update_idletasks()
    dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

def forget_api_key():
    delete_api_key_from_keyring()
    # Do not forcibly clear session key (session-only key remains until restarted),
    # but re-init client without explicit key so SDK falls back to env var (if any).
    init_client_with_key(None)
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, "API key removed from system keychain. If you set a key for this session it will remain active until the app restarts.\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)
    update_api_widgets()

def test_api_key():
    """
    Manual re-validation of the currently stored key (keyring or env or session).
    Runs in background and reports success/failure.
    """
    # Prefer session key, then keyring/env
    candidate = current_session_key or load_api_key()
    if not candidate:
        messagebox.showinfo("No API Key", "No API key is set. Use Key -> Set API Key first.")
        return

    def worker():
        try:
            temp_client = OpenAI(api_key=candidate)
            temp_client.chat.completions.create(
                model=_default_model,
                messages=[{"role": "user", "content": "Say ok in one word"}],
                max_completion_tokens=1
            )
        except Exception as exc:
            err_msg = str(exc)
            app.after(0, lambda msg=err_msg: messagebox.showerror("Test Failed", f"API key test failed:\n\n{msg}"))
            return
        app.after(0, lambda: messagebox.showinfo("Test Succeeded", "API key is valid."))

    threading.Thread(target=worker, daemon=True).start()

# -----------------------------
# Initialize the OpenAI client variable (we'll initialize properly later)
# -----------------------------
client = None

# Default model: prefer the config value if present and in the list, otherwise use first available
_default_model = DEFAULT_MODEL_VERSION if DEFAULT_MODEL_VERSION in AVAILABLE_MODELS else AVAILABLE_MODELS[0]

# -----------------------------
# Tkinter app state & helpers
# -----------------------------
conversation = [
    {"role": "system", "content": f"You are chatting with a user. Respond helpfully. Your name is {ASSISTANT_NAME}"}
]

conversation_lock = threading.Lock()

waiting = False
anim_after_id = None
anim_dots = 0

image_refs = []
default_image_folder = os.getcwd()

def animate_wait():
    global anim_dots, anim_after_id
    if not waiting:
        return
    anim_dots = (anim_dots + 1) % 4
    status_label.config(text="Thinking" + "." * anim_dots)
    anim_after_id = app.after(500, animate_wait)

def start_waiting():
    global waiting, anim_dots, anim_after_id
    if waiting:
        return
    waiting = True
    anim_dots = 0
    status_label.config(text="Thinking")
    anim_after_id = app.after(500, animate_wait)

def stop_waiting():
    global waiting, anim_after_id
    if not waiting:
        return
    waiting = False
    if anim_after_id is not None:
        try:
            app.after_cancel(anim_after_id)
        except Exception:
            pass
        anim_after_id = None
    status_label.config(text="Idle")

# -----------------------------
# Chat send (streaming) & image generation
# -----------------------------
def send_message():
    user_message = user_input.get("1.0", tk.END).strip()
    if not user_message:
        return

    # Disable the send button on the main thread immediately
    send_button.config(state='disabled')

    with conversation_lock:
        conversation.append({"role": "user", "content": user_message})

    def show_user_message():
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "You: " + user_message + "\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
        user_input.delete("1.0", tk.END)

    app.after(0, show_user_message)
    start_waiting()

    selected_model = current_model_var.get()

    def worker(model_to_use):
        try:
            with conversation_lock:
                messages_for_api = conversation.copy()

            stream = client.chat.completions.create(
                model=model_to_use,
                messages=messages_for_api,
                stream=True
            )

            def start_assistant_message():
                chat_history.configure(state='normal')
                sep = "\n--- Model response ---\n"
                chat_history.insert(tk.END, sep, "separator")
                chat_history.insert(tk.END, f"{ASSISTANT_NAME}: ")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)

            app.after(0, start_assistant_message)

            assistant_full = ""

            for event in stream:
                delta_text = ""
                try:
                    choice0 = event.choices[0]
                    delta = getattr(choice0, "delta", None)
                    if delta is None:
                        delta = choice0.get("delta", {})
                    if hasattr(delta, "content"):
                        delta_text = delta.content or ""
                    else:
                        delta_text = delta.get("content", "") if isinstance(delta, dict) else ""
                except Exception:
                    delta_text = ""

                if delta_text:
                    assistant_full += delta_text
                    def append_chunk(chunk=delta_text):
                        chat_history.configure(state='normal')
                        chat_history.insert(tk.END, chunk)
                        chat_history.configure(state='disabled')
                        chat_history.see(tk.END)
                    app.after(0, append_chunk)

            def finalize_assistant_message():
                chat_history.configure(state='normal')
                chat_history.insert(tk.END, "\n\n")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)

            app.after(0, finalize_assistant_message)

            with conversation_lock:
                conversation.append({"role": "assistant", "content": assistant_full})

        except Exception as e:
            def show_error():
                chat_history.configure(state='normal')
                chat_history.insert(tk.END, "Error: " + str(e) + "\n\n")
                chat_history.configure(state='disabled')
                chat_history.see(tk.END)
            app.after(0, show_error)

        finally:
            def on_request_complete():
                send_button.config(state='normal')
                stop_waiting()
            app.after(0, on_request_complete)

    t = threading.Thread(target=worker, args=(selected_model,), daemon=True)
    t.start()

def export_chat():
    filename = f'chat_history-{datetime.now().strftime("%m%b%y-%H%M")}.txt'
    chat_content = chat_history.get('1.0', tk.END)
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(chat_content)
    print(f"Exported {filename}")

def read_text_file(path):
    with open(path, 'r', encoding='utf-8', errors='replace') as f:
        return f.read()

def read_docx_file(path):
    try:
        doc = Document(path)
    except Exception as e:
        raise RuntimeError(f"Error reading DOCX: {e}")
    paragraphs = [p.text for p in doc.paragraphs]
    return "\n".join(paragraphs)

def read_pdf_file(path):
    try:
        reader = PdfReader(path)
    except Exception as e:
        raise RuntimeError(f"Error opening PDF: {e}")
    text_chunks = []
    for page in reader.pages:
        try:
            text = page.extract_text()
        except Exception:
            text = None
        if text:
            text_chunks.append(text)
    return "\n\n".join(text_chunks)

def read_excel_file(path):
    try:
        import pandas as pd
        sheets = pd.read_excel(path, sheet_name=None)
        parts = []
        for sheet_name, df in sheets.items():
            parts.append(f"Sheet: {sheet_name}")
            parts.append(df.to_csv(sep='\t', index=False))
        return "\n\n".join(parts)
    except Exception as pandas_err:
        try:
            from openpyxl import load_workbook
            wb = load_workbook(path, read_only=True, data_only=True)
            parts = []
            for sheet_name in wb.sheetnames:
                ws = wb[sheet_name]
                parts.append(f"Sheet: {sheet_name}")
                rows = []
                for row in ws.iter_rows(values_only=True):
                    row_text = "\t".join("" if v is None else str(v) for v in row)
                    rows.append(row_text)
                parts.append("\n".join(rows))
            return "\n\n".join(parts)
        except Exception as openpyxl_err:
            raise RuntimeError(
                "Failed to read Excel file. pandas error: "
                f"{pandas_err}; openpyxl error: {openpyxl_err}. "
                "To add Excel support install pandas and openpyxl (e.g. pip install pandas openpyxl)."
            )

def import_file():
    filepath = filedialog.askopenfilename(
        title="Import file for context",
        filetypes=[
            ("All files", "*.*"),
            ("Text files", "*.txt;*.md"),
            ("Word documents", "*.docx"),
            ("PDF files", "*.pdf"),
            ("Excel files", "*.xls;*.xlsx")
        ]
    )
    if not filepath:
        return

    ext = os.path.splitext(filepath)[1].lower()
    try:
        if ext in ('.txt', '.md'):
            content = read_text_file(filepath)
        elif ext == '.docx':
            content = read_docx_file(filepath)
        elif ext == '.pdf':
            content = read_pdf_file(filepath)
        elif ext in ('.xls', '.xlsx'):
            content = read_excel_file(filepath)
        else:
            try:
                content = read_text_file(filepath)
            except Exception:
                raise RuntimeError("Unsupported file type and not readable as text.")
    except Exception as e:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, f"Error importing file {os.path.basename(filepath)}: {e}\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
        return

    max_chars_warn = 200_000
    if len(content) > max_chars_warn:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END,
                            f"Warning: imported file is very large ({len(content)} chars). "
                            "You may want to summarize or split it before sending to the model.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

    with conversation_lock:
        conversation.append({"role": "user", "content": content})

    preview_limit = 1000
    preview = content if len(content) <= preview_limit else content[:preview_limit] + "\n...[truncated preview]"
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"You (imported {os.path.basename(filepath)}):\n{preview}\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

# ------------------------------
# Image generation functions
# ------------------------------
def generate_image_dialog():
    dlg = tk.Toplevel(app)
    dlg.title("Generate Image")
    dlg.grab_set()

    tk.Label(dlg, text="Enter image prompt:").grid(row=0, column=0, padx=8, pady=(8, 0), sticky='w')
    prompt_text = tk.Text(dlg, wrap=tk.WORD, width=60, height=6)
    prompt_text.grid(row=1, column=0, padx=8, pady=8, sticky='nsew')

    size_frame = tk.Frame(dlg)
    size_frame.grid(row=2, column=0, sticky='w', padx=8)
    tk.Label(size_frame, text="Size:").pack(side='left', padx=(0,6))
    size_var = tk.StringVar(value="1024x1024")
    size_choices = ["256x256", "512x512", "1024x1024"]
    size_menu = tk.OptionMenu(size_frame, size_var, *size_choices)
    size_menu.pack(side='left')

    folder_frame = tk.Frame(dlg)
    folder_frame.grid(row=3, column=0, sticky='we', padx=8, pady=(6, 0))
    tk.Label(folder_frame, text="Save folder:").pack(side='left')
    folder_label_var = tk.StringVar(value=default_image_folder)
    folder_label = tk.Label(folder_frame, textvariable=folder_label_var, anchor='w')
    folder_label.pack(side='left', padx=(6,8), fill='x', expand=True)

    def choose_folder():
        chosen = filedialog.askdirectory(title="Choose folder to save images", initialdir=folder_label_var.get() or os.getcwd())
        if chosen:
            folder_label_var.set(chosen)

    choose_btn = tk.Button(folder_frame, text="Choose...", command=choose_folder)
    choose_btn.pack(side='right')

    button_frame = tk.Frame(dlg)
    button_frame.grid(row=4, column=0, pady=(8, 8), sticky='e')

    def on_submit():
        prompt = prompt_text.get("1.0", tk.END).strip()
        if not prompt:
            return
        size = size_var.get()
        folder = folder_label_var.get() or os.getcwd()
        dlg.destroy()
        start_image_generation(prompt, size, folder)

    submit_btn = tk.Button(button_frame, text="Generate", command=on_submit)
    submit_btn.pack(side='right', padx=5)
    cancel_btn = tk.Button(button_frame, text="Cancel", command=dlg.destroy)
    cancel_btn.pack(side='right')

    dlg.update_idletasks()
    dlg.minsize(dlg.winfo_reqwidth(), dlg.winfo_reqheight())

def start_image_generation(prompt, size, folder):
    with conversation_lock:
        conversation.append({"role": "user", "content": f"[Image prompt] {prompt}"})

    app.after(0, lambda: show_user_prompt_ui(prompt, size))
    start_waiting()
    send_button.config(state='disabled')

    t = threading.Thread(target=image_worker, args=(prompt, size, folder), daemon=True)
    t.start()

def image_worker(prompt, size, folder):
    try:
        os.makedirs(folder, exist_ok=True)

        response = client.images.generate(
            model=IMAGE_MODEL_VERSION,
            prompt=prompt,
            size=size
        )

        img_b64 = None
        img_url = None
        try:
            first = response.data[0]
            img_b64 = getattr(first, "b64_json", None) or (first.get("b64_json") if isinstance(first, dict) else None)
            img_url = getattr(first, "url", None) or (first.get("url") if isinstance(first, dict) else None)
        except Exception:
            pass

        saved_filename = None
        if img_b64:
            try:
                img_bytes = base64.b64decode(img_b64)
                saved_filename = os.path.join(folder, f"image-{datetime.now().strftime('%Y%m%d-%H%M%S')}.png")
                with open(saved_filename, "wb") as f:
                    f.write(img_bytes)
            except Exception as e:
                raise RuntimeError(f"Failed to decode/save image: {e}")
        elif img_url:
            try:
                saved_filename = os.path.join(folder, f"image-{datetime.now().strftime('%Y%m%d-%H%M%S')}.png")
                urllib.request.urlretrieve(img_url, saved_filename)
            except Exception as e:
                raise RuntimeError(f"Failed to download image from URL: {e}")
        else:
            raise RuntimeError(f"No image data returned. Response: {response}")

        assistant_text = f"[Image generated: {saved_filename}] (prompt: {prompt})"
        with conversation_lock:
            conversation.append({"role": "assistant", "content": assistant_text})

        app.after(0, lambda: show_assistant_image_ui(saved_filename, assistant_text))

    except Exception as e:
        print("Image generation error:", traceback.format_exc())
        app.after(0, lambda: show_image_error_ui(e))

    finally:
        app.after(0, cleanup_after_image)

def show_user_prompt_ui(prompt, size):
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"You (image prompt, {size}): {prompt}\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

def show_assistant_image_ui(saved_filename, assistant_text):
    try:
        chat_history.configure(state='normal')
        sep = "\n--- Model response ---\n"
        chat_history.insert(tk.END, sep, "separator")
        chat_history.insert(tk.END, f"{ASSISTANT_NAME}: {assistant_text}\n")

        pil_img = Image.open(saved_filename)

        chat_width = chat_history.winfo_width()
        if not chat_width or chat_width < 50:
            max_display_width = 600
        else:
            max_display_width = max(200, chat_width - 80)

        w, h = pil_img.size
        if w > max_display_width:
            ratio = max_display_width / w
            new_size = (int(w * ratio), int(h * ratio))
            pil_img = pil_img.resize(new_size, resample=RESAMPLE_FILTER)

        tk_img = ImageTk.PhotoImage(pil_img)
        image_refs.append(tk_img)

        chat_history.image_create(tk.END, image=tk_img)
        chat_history.insert(tk.END, "\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

    except Exception as e_ui:
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, f"Error displaying image: {e_ui}\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)

def show_image_error_ui(exc):
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, "Error generating image: " + str(exc) + "\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

def cleanup_after_image():
    send_button.config(state='normal')
    stop_waiting()

# ------------------------------
# Model menu change handler
# ------------------------------
def on_model_change():
    selected = current_model_var.get()
    chat_history.configure(state='normal')
    chat_history.insert(tk.END, f"[Model switched to: {selected}]\n\n")
    chat_history.configure(state='disabled')
    chat_history.see(tk.END)

# ------------------------------
# Build the GUI
# ------------------------------
app = tk.Tk()
app.title("GPT GUIde")

# Default UI model selection variable
current_model_var = tk.StringVar(app, value=_default_model)

menu = Menu(app)
app.config(menu=menu)

# File menu
filemenu = Menu(menu, tearoff=0)
menu.add_cascade(label="File", menu=filemenu)
filemenu.add_command(label="Export Chat", command=export_chat)
filemenu.add_command(label="Import File", command=import_file)
filemenu.add_command(label="Generate Image...", command=generate_image_dialog)
# capture index of generate image command so we can enable/disable it later
_generate_image_menu_index = filemenu.index("end")

# Model menu
modelmenu = Menu(menu, tearoff=0)
menu.add_cascade(label="Model", menu=modelmenu)
for m in AVAILABLE_MODELS:
    modelmenu.add_radiobutton(label=m, variable=current_model_var, value=m, command=on_model_change)

# Key menu (Set / Forget / Test)
keymenu = Menu(menu, tearoff=0)
menu.add_cascade(label="Key", menu=keymenu)
keymenu.add_command(label="Set API Key", command=lambda: set_api_key_dialog(app))
keymenu.add_command(label="Forget API Key", command=forget_api_key)
keymenu.add_command(label="Test API Key", command=test_api_key)

# Configure grid weights
app.grid_rowconfigure(0, weight=1)
app.grid_rowconfigure(1, weight=0)
app.grid_rowconfigure(2, weight=0)
app.grid_rowconfigure(3, weight=0)
app.grid_columnconfigure(0, weight=1)
app.grid_columnconfigure(1, weight=0, minsize=80)

chat_history = scrolledtext.ScrolledText(app, state='disabled', wrap=tk.WORD)
chat_history.grid(row=0, column=0, columnspan=2, padx=10, pady=10, sticky='nsew')

default_font = tkfont.nametofont("TkDefaultFont")
sep_font = default_font.copy()
try:
    sep_font.configure(size=max(default_font.cget("size") - 2, 8), slant='italic')
except Exception:
    sep_font = ("TkDefaultFont", max(default_font.cget("size") - 2, 8), "italic")
chat_history.tag_configure("separator", font=sep_font, foreground="gray")

user_input = tk.Text(app, wrap=tk.WORD, height=4)
user_input.grid(row=1, column=0, padx=10, pady=10, sticky='nsew')

send_button = tk.Button(app, text="Send", command=send_message)
send_button.grid(row=1, column=1, padx=10, pady=10, sticky='ns')

status_label = tk.Label(app, text="Idle", anchor='w')
status_label.grid(row=2, column=0, columnspan=2, sticky='ew', padx=10, pady=(0,2))

credit_font = default_font.copy()
try:
    credit_font.configure(size=max(default_font.cget("size") - 3, 8), slant='italic')
except Exception:
    credit_font = ("TkDefaultFont", max(default_font.cget("size") - 3, 8), "italic")
credit_label = tk.Label(app, text="Created by David Miles", anchor='e', font=credit_font, foreground="gray30")
credit_label.grid(row=3, column=0, columnspan=2, sticky='ew', padx=10, pady=(0,10))

app.update_idletasks()
min_w = app.winfo_reqwidth()
min_h = app.winfo_reqheight()
app.minsize(min_w, min_h)
app.geometry(f"{min_w}x{min_h}")

# ------------------------------
# API key initialization + widget enabling
# ------------------------------
# Initialize client using any existing key (keyring or env)
initial_key = load_api_key()
init_client_with_key(initial_key)

def update_api_widgets():
    """
    Enable or disable UI elements that require an API key.
    Criteria: session key present (current_session_key) OR environment variable present.
    """
    has_env_key = bool(os.getenv("OPENAI_KEY"))
    has_key_for_session = bool(current_session_key) or has_env_key

    # Send button
    try:
        send_button.config(state='normal' if has_key_for_session else 'disabled')
    except Exception:
        pass

    # Generate Image menu entry (in File menu), using the captured index
    try:
        filemenu.entryconfig(_generate_image_menu_index, state='normal' if has_key_for_session else 'disabled')
    except Exception:
        pass

# Warn in chat if no key present and update widgets accordingly
def check_api_key_and_warn():
    if load_api_key() is None and not current_session_key and not os.getenv("OPENAI_KEY"):
        chat_history.configure(state='normal')
        chat_history.insert(tk.END, "Warning: No API key set. OpenAI requests will fail until you set a key under Key -> Set API Key.\n\n")
        chat_history.configure(state='disabled')
        chat_history.see(tk.END)
    update_api_widgets()

# Call initial check now that widgets exist
check_api_key_and_warn()

# Start main loop
app.mainloop()
```

If you want, I can also:
- Run a quick automated scan and replace any other legacy parameter names if you plan to use different endpoints.
- Add a small status indicator (e.g., "API key: saved / session-only / none") to the status bar to make key state more visible.


